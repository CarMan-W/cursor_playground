<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sphere STL Generator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: Arial, Helvetica, sans-serif;
    }

    body {
      margin: 0;
      padding: 2rem 1rem;
      background: #f5f7fb;
      color: #202737;
    }

    .card {
      max-width: 640px;
      margin: 0 auto;
      background: #ffffff;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
    }

    h1 {
      margin-top: 0;
      font-size: 1.5rem;
    }

    p {
      line-height: 1.5;
    }

    .field {
      display: grid;
      gap: 0.4rem;
      margin: 1rem 0;
    }

    label {
      font-weight: 600;
    }

    input[type="number"],
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.65rem 0.75rem;
      border: 1px solid #c2cadb;
      border-radius: 8px;
      font-size: 1rem;
      background: #fff;
      color: #202737;
    }

    button {
      border: 0;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: #2b5cff;
      color: #fff;
    }

    button[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .hint {
      color: #4a5670;
      margin-top: 0.75rem;
      font-size: 0.95rem;
    }

    #status {
      margin-top: 1rem;
      min-height: 1.4rem;
      font-weight: 600;
    }

    .ok {
      color: #0f7a2a;
    }

    .err {
      color: #b42318;
    }
  </style>
</head>
<body>
  <main class="card">
    <h1>Sphere STL Generator</h1>
    <p>Enter a sphere diameter in millimeters, then click the button to generate and download a watertight ASCII STL file.</p>

    <div class="field">
      <label for="diameter">Sphere Diameter (mm)</label>
      <input id="diameter" type="number" min="0.001" step="0.001" value="3.0" required>
    </div>

    <div class="field">
      <label for="void-shape">Internal Void Shape</label>
      <select id="void-shape">
        <option value="none" selected>None (solid sphere)</option>
        <option value="sphere">Sphere</option>
        <option value="cube">Cube</option>
      </select>
    </div>

    <div class="field">
      <label for="void-size" id="void-size-label">Void Size (mm)</label>
      <input id="void-size" type="number" min="0.001" step="0.001" value="1.0" disabled>
      <div class="hint" id="void-size-hint">Enable by choosing an internal void shape.</div>
    </div>

    <button id="generate">Generate and Download STL</button>
    <div class="hint">
      Mesh quality is fixed at latitude=48 and longitude=96 for smooth output.
      Void size means diameter for a spherical void and edge length for a cube void.
    </div>
    <div id="status" aria-live="polite"></div>
  </main>

  <script>
    const LAT_SEGMENTS = 48;
    const LON_SEGMENTS = 96;

    function subtract(a, b) {
      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    function cross(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    }

    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function normalize(v) {
      const length = Math.sqrt(dot(v, v));
      if (length === 0) {
        return [0, 0, 0];
      }
      return [v[0] / length, v[1] / length, v[2] / length];
    }

    function average(a, b, c) {
      return [
        (a[0] + b[0] + c[0]) / 3,
        (a[1] + b[1] + c[1]) / 3,
        (a[2] + b[2] + c[2]) / 3
      ];
    }

    function orientOutward(v1, v2, v3) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const c = average(v1, v2, v3);
      if (dot(n, c) < 0) {
        return { v1, v2: v3, v3: v2 };
      }
      return { v1, v2, v3 };
    }

    function orientInward(v1, v2, v3) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const c = average(v1, v2, v3);
      if (dot(n, c) > 0) {
        return { v1, v2: v3, v3: v2 };
      }
      return { v1, v2, v3 };
    }

    function buildSphereMesh(radiusMm, latSegments, lonSegments) {
      if (!(radiusMm > 0)) {
        throw new Error("Diameter must be greater than 0.");
      }
      if (latSegments < 2) {
        throw new Error("latSegments must be >= 2.");
      }
      if (lonSegments < 3) {
        throw new Error("lonSegments must be >= 3.");
      }

      const top = [0, 0, radiusMm];
      const bottom = [0, 0, -radiusMm];
      const rings = [];

      for (let i = 1; i < latSegments; i += 1) {
        const theta = Math.PI * i / latSegments;
        const z = radiusMm * Math.cos(theta);
        const ringRadius = radiusMm * Math.sin(theta);
        const ring = [];
        for (let j = 0; j < lonSegments; j += 1) {
          const phi = 2 * Math.PI * j / lonSegments;
          const x = ringRadius * Math.cos(phi);
          const y = ringRadius * Math.sin(phi);
          ring.push([x, y, z]);
        }
        rings.push(ring);
      }

      const triangles = [];
      const firstRing = rings[0];
      const lastRing = rings[rings.length - 1];

      for (let j = 0; j < lonSegments; j += 1) {
        const v2 = firstRing[(j + 1) % lonSegments];
        const v3 = firstRing[j];
        triangles.push(orientOutward(top, v2, v3));
      }

      for (let ringIdx = 0; ringIdx < rings.length - 1; ringIdx += 1) {
        const ringA = rings[ringIdx];
        const ringB = rings[ringIdx + 1];
        for (let j = 0; j < lonSegments; j += 1) {
          const v00 = ringA[j];
          const v01 = ringA[(j + 1) % lonSegments];
          const v10 = ringB[j];
          const v11 = ringB[(j + 1) % lonSegments];
          triangles.push(orientOutward(v00, v01, v11));
          triangles.push(orientOutward(v00, v11, v10));
        }
      }

      for (let j = 0; j < lonSegments; j += 1) {
        const v2 = lastRing[j];
        const v3 = lastRing[(j + 1) % lonSegments];
        triangles.push(orientOutward(bottom, v2, v3));
      }

      return triangles;
    }

    function buildCubeVoidMesh(edgeMm) {
      if (!(edgeMm > 0)) {
        throw new Error("Cube void size must be greater than 0.");
      }
      const half = edgeMm / 2;
      const faces = [
        // +X
        [[half, -half, -half], [half, half, -half], [half, half, half], [half, -half, half]],
        // -X
        [[-half, -half, -half], [-half, -half, half], [-half, half, half], [-half, half, -half]],
        // +Y
        [[-half, half, -half], [-half, half, half], [half, half, half], [half, half, -half]],
        // -Y
        [[-half, -half, -half], [half, -half, -half], [half, -half, half], [-half, -half, half]],
        // +Z
        [[-half, -half, half], [half, -half, half], [half, half, half], [-half, half, half]],
        // -Z
        [[-half, -half, -half], [-half, half, -half], [half, half, -half], [half, -half, -half]]
      ];

      const triangles = [];
      for (const [a, b, c, d] of faces) {
        triangles.push(orientInward(a, b, c));
        triangles.push(orientInward(a, c, d));
      }
      return triangles;
    }

    function flipTriangleWinding(tri) {
      return { v1: tri.v1, v2: tri.v3, v3: tri.v2 };
    }

    function triangleNormal(tri) {
      const raw = cross(subtract(tri.v2, tri.v1), subtract(tri.v3, tri.v1));
      return normalize(raw);
    }

    function formatNumber(n) {
      return n.toFixed(8);
    }

    function buildAsciiStl(solidName, triangles) {
      const lines = [];
      lines.push(`solid ${solidName}`);
      for (const tri of triangles) {
        const n = triangleNormal(tri);
        lines.push(`  facet normal ${formatNumber(n[0])} ${formatNumber(n[1])} ${formatNumber(n[2])}`);
        lines.push("    outer loop");
        lines.push(`      vertex ${formatNumber(tri.v1[0])} ${formatNumber(tri.v1[1])} ${formatNumber(tri.v1[2])}`);
        lines.push(`      vertex ${formatNumber(tri.v2[0])} ${formatNumber(tri.v2[1])} ${formatNumber(tri.v2[2])}`);
        lines.push(`      vertex ${formatNumber(tri.v3[0])} ${formatNumber(tri.v3[1])} ${formatNumber(tri.v3[2])}`);
        lines.push("    endloop");
        lines.push("  endfacet");
      }
      lines.push(`endsolid ${solidName}`);
      return `${lines.join("\n")}\n`;
    }

    function formatDimension(value) {
      return value.toFixed(3).replace(/\.?0+$/, "").replace(".", "p");
    }

    function makeFileName(diameter, voidShape, voidSize) {
      const dText = formatDimension(diameter);
      if (voidShape === "none") {
        return `sphere_${dText}mm_solid.stl`;
      }
      const sText = formatDimension(voidSize);
      return `sphere_${dText}mm_void_${voidShape}_${sText}mm.stl`;
    }

    function setStatus(message, isError) {
      const statusEl = document.getElementById("status");
      statusEl.textContent = message;
      statusEl.className = isError ? "err" : "ok";
    }

    function downloadTextFile(fileName, content) {
      const blob = new Blob([content], { type: "model/stl" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      link.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    function validateVoidConfig(diameter, voidShape, voidSize) {
      if (voidShape === "none") {
        return;
      }
      if (!Number.isFinite(voidSize) || voidSize <= 0) {
        throw new Error("Please enter a void size greater than 0.");
      }

      const outerRadius = diameter / 2;
      if (voidShape === "sphere") {
        const voidRadius = voidSize / 2;
        if (voidRadius >= outerRadius) {
          throw new Error("Sphere void diameter must be smaller than the outer sphere diameter.");
        }
        return;
      }

      if (voidShape === "cube") {
        const halfDiagonal = (voidSize * Math.sqrt(3)) / 2;
        if (halfDiagonal >= outerRadius) {
          throw new Error("Cube void is too large; cube must fit fully inside the sphere.");
        }
        return;
      }

      throw new Error(`Unsupported void shape: ${voidShape}`);
    }

    function buildSphereWithOptionalVoid(diameter, voidShape, voidSize) {
      const outerTriangles = buildSphereMesh(diameter / 2, LAT_SEGMENTS, LON_SEGMENTS);
      validateVoidConfig(diameter, voidShape, voidSize);

      if (voidShape === "none") {
        return outerTriangles;
      }

      if (voidShape === "sphere") {
        const cavity = buildSphereMesh(voidSize / 2, LAT_SEGMENTS, LON_SEGMENTS).map(flipTriangleWinding);
        return outerTriangles.concat(cavity);
      }

      if (voidShape === "cube") {
        return outerTriangles.concat(buildCubeVoidMesh(voidSize));
      }

      throw new Error(`Unsupported void shape: ${voidShape}`);
    }

    const voidShapeEl = document.getElementById("void-shape");
    const voidSizeEl = document.getElementById("void-size");
    const voidSizeLabelEl = document.getElementById("void-size-label");
    const voidSizeHintEl = document.getElementById("void-size-hint");

    function updateVoidSizeUi() {
      const shape = voidShapeEl.value;
      const hasVoid = shape !== "none";
      voidSizeEl.disabled = !hasVoid;

      if (!hasVoid) {
        voidSizeLabelEl.textContent = "Void Size (mm)";
        voidSizeHintEl.textContent = "Enable by choosing an internal void shape.";
        return;
      }

      if (shape === "sphere") {
        voidSizeLabelEl.textContent = "Void Sphere Diameter (mm)";
        voidSizeHintEl.textContent = "The void sphere diameter must be smaller than the outer sphere diameter.";
        return;
      }

      voidSizeLabelEl.textContent = "Void Cube Edge Length (mm)";
      voidSizeHintEl.textContent = "The cube must fit entirely inside the sphere.";
    }

    voidShapeEl.addEventListener("change", updateVoidSizeUi);
    updateVoidSizeUi();

    document.getElementById("generate").addEventListener("click", () => {
      const button = document.getElementById("generate");
      const diameterInput = document.getElementById("diameter");
      const voidShape = voidShapeEl.value;
      const voidSize = Number(voidSizeEl.value);
      const diameter = Number(diameterInput.value);

      if (!Number.isFinite(diameter) || diameter <= 0) {
        setStatus("Please enter a valid diameter greater than 0.", true);
        return;
      }

      button.disabled = true;
      button.textContent = "Generating...";

      try {
        const triangles = buildSphereWithOptionalVoid(diameter, voidShape, voidSize);
        const solidName = voidShape === "none" ? "sphere_solid" : `sphere_with_${voidShape}_void`;
        const stlText = buildAsciiStl(solidName, triangles);
        const fileName = makeFileName(diameter, voidShape, voidSize);
        downloadTextFile(fileName, stlText);
        const voidText = voidShape === "none" ? "no internal void" : `void=${voidShape} (${voidSize} mm)`;
        setStatus(`Done. Downloaded ${fileName} with ${triangles.length} facets (${voidText}).`, false);
      } catch (error) {
        setStatus(error instanceof Error ? error.message : "Failed to generate STL.", true);
      } finally {
        button.disabled = false;
        button.textContent = "Generate and Download STL";
      }
    });
  </script>
</body>
</html>
