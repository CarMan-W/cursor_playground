<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sphere Mesh Generator</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: Arial, Helvetica, sans-serif;
    }

    body {
      margin: 0;
      padding: 1.5rem 1rem;
      background: #f5f7fb;
      color: #202737;
    }

    .layout {
      max-width: 1120px;
      margin: 0 auto;
      display: grid;
      gap: 1rem;
      grid-template-columns: minmax(320px, 440px) 1fr;
      align-items: start;
    }

    .card {
      background: #ffffff;
      border-radius: 12px;
      padding: 1.25rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
    }

    h1,
    h2 {
      margin-top: 0;
    }

    h1 {
      font-size: 1.5rem;
      margin-bottom: 0.75rem;
    }

    h2 {
      font-size: 1.15rem;
      margin-bottom: 0.6rem;
    }

    p {
      line-height: 1.5;
    }

    .field {
      display: grid;
      gap: 0.4rem;
      margin: 0.9rem 0;
    }

    label {
      font-weight: 600;
    }

    input[type="number"],
    select {
      width: 100%;
      box-sizing: border-box;
      padding: 0.65rem 0.75rem;
      border: 1px solid #c2cadb;
      border-radius: 8px;
      font-size: 1rem;
      background: #fff;
      color: #202737;
    }

    button {
      border: 0;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      background: #2b5cff;
      color: #fff;
      width: 100%;
    }

    button[disabled] {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .hint {
      color: #4a5670;
      margin-top: 0.35rem;
      font-size: 0.93rem;
      line-height: 1.4;
    }

    #status {
      margin-top: 0.9rem;
      min-height: 1.4rem;
      font-weight: 600;
    }

    .ok {
      color: #0f7a2a;
    }

    .err {
      color: #b42318;
    }

    .preview-panel {
      min-height: 520px;
    }

    .preview-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.75rem;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }

    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .zoom-btn {
      width: auto;
      min-width: 2.2rem;
      padding: 0.45rem 0.7rem;
      background: #3a4e8a;
      font-size: 0.95rem;
    }

    .zoom-btn.secondary {
      background: #566287;
    }

    .zoom-level {
      min-width: 3.2rem;
      text-align: center;
      font-weight: 600;
      color: #324266;
    }

    #preview-canvas {
      width: 100%;
      height: auto;
      max-height: 520px;
      border: 1px solid #d2daeb;
      border-radius: 10px;
      display: block;
      background: #eef3ff;
    }

    @media (max-width: 960px) {
      .layout {
        grid-template-columns: 1fr;
      }

      .preview-panel {
        min-height: auto;
      }
    }
  </style>
</head>

<body>
  <main class="layout">
    <section class="card">
      <h1>Sphere Mesh Generator</h1>
      <p>Set geometry options, preview the result, then download as STL or 3MF.</p>

      <div class="field">
        <label for="diameter">Sphere Diameter (mm)</label>
        <input id="diameter" type="number" min="0.001" step="0.001" value="3.0" required>
      </div>

      <div class="field">
        <label for="split-half">Split Sphere Half</label>
        <select id="split-half">
          <option value="none" selected>None (full sphere)</option>
          <option value="up">Upper half (Z &gt;= 0)</option>
          <option value="down">Lower half (Z &lt;= 0)</option>
          <option value="both">Both halves (split in middle)</option>
        </select>
        <div class="hint" id="split-half-hint">None keeps the full sphere.</div>
      </div>

      <div class="field">
        <label for="void-shape">Internal Void Shape</label>
        <select id="void-shape">
          <option value="none" selected>None (solid sphere)</option>
          <option value="sphere">Sphere</option>
          <option value="cube">Cube</option>
        </select>
      </div>

      <div class="field">
        <label for="void-size" id="void-size-label">Void Size (mm)</label>
        <input id="void-size" type="number" min="0.001" step="0.001" value="1.0" disabled>
        <div class="hint" id="void-size-hint">Enable by choosing an internal void shape.</div>
      </div>

      <div class="field">
        <label for="array-x">Array Count X</label>
        <input id="array-x" type="number" min="1" step="1" value="1" required>
      </div>

      <div class="field">
        <label for="array-y">Array Count Y</label>
        <input id="array-y" type="number" min="1" step="1" value="1" required>
      </div>

      <div class="field">
        <label for="array-spacing">Array Spacing (mm, center-to-center)</label>
        <input id="array-spacing" type="number" min="0.001" step="0.001" value="100.0" disabled>
        <div class="hint" id="array-spacing-hint">Single object (1x1): spacing is ignored.</div>
      </div>

      <div class="field">
        <label for="corner-anchors">Corner Anchors</label>
        <select id="corner-anchors">
          <option value="off" selected>Off</option>
          <option value="on">On (4 pyramid anchors)</option>
        </select>
        <div class="hint">Adds anchors at one array spacing outside the array corners.</div>
      </div>

      <div class="field">
        <label for="export-format">Export Format</label>
        <select id="export-format">
          <option value="stl" selected>STL (.stl)</option>
          <option value="3mf">3MF (.3mf)</option>
        </select>
      </div>

      <button id="generate">Generate and Download</button>
      <div class="hint">
        Export mesh quality is fixed at latitude=48 and longitude=96.
        Split mode can output upper/lower/both halves after applying internal void.
      </div>
      <div id="status" aria-live="polite"></div>
    </section>

    <section class="card preview-panel">
      <h2>Preview</h2>
      <div class="preview-toolbar">
        <div class="hint">Mouse wheel to zoom. Dragging is not required.</div>
        <div class="zoom-controls">
          <button id="zoom-out" class="zoom-btn" type="button" aria-label="Zoom out">-</button>
          <span id="zoom-level" class="zoom-level" aria-live="polite">100%</span>
          <button id="zoom-in" class="zoom-btn" type="button" aria-label="Zoom in">+</button>
          <button id="zoom-reset" class="zoom-btn secondary" type="button" aria-label="Reset zoom">Reset</button>
        </div>
      </div>
      <canvas id="preview-canvas" width="780" height="520" aria-label="Mesh preview"></canvas>
      <div class="hint" id="preview-note">
        Live preview uses a lighter mesh for responsiveness.
      </div>
    </section>
  </main>

  <script>
    const LAT_SEGMENTS = 48;
    const LON_SEGMENTS = 96;
    const PREVIEW_LAT_SEGMENTS = 18;
    const PREVIEW_LON_SEGMENTS = 36;
    const PREVIEW_MAX_OBJECTS = 25;
    const PREVIEW_TRIANGLE_LIMIT = 18000;
    const PREVIEW_BASE_CAMERA_DISTANCE_FACTOR = 4.0;
    const PREVIEW_MIN_ZOOM = 0.4;
    const PREVIEW_MAX_ZOOM = 4.0;

    function subtract(a, b) {
      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
    }

    function cross(a, b) {
      return [
        a[1] * b[2] - a[2] * b[1],
        a[2] * b[0] - a[0] * b[2],
        a[0] * b[1] - a[1] * b[0]
      ];
    }

    function dot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function normalize(v) {
      const length = Math.sqrt(dot(v, v));
      if (length === 0) {
        return [0, 0, 0];
      }
      return [v[0] / length, v[1] / length, v[2] / length];
    }

    function snapNearZero(value, eps = 1e-12) {
      return Math.abs(value) < eps ? 0 : value;
    }

    function average(a, b, c) {
      return [
        (a[0] + b[0] + c[0]) / 3,
        (a[1] + b[1] + c[1]) / 3,
        (a[2] + b[2] + c[2]) / 3
      ];
    }

    function orientOutward(v1, v2, v3) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const c = average(v1, v2, v3);
      if (dot(n, c) < 0) {
        return { v1, v2: v3, v3: v2 };
      }
      return { v1, v2, v3 };
    }

    function orientInward(v1, v2, v3) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const c = average(v1, v2, v3);
      if (dot(n, c) > 0) {
        return { v1, v2: v3, v3: v2 };
      }
      return { v1, v2, v3 };
    }

    function buildSphereMesh(radiusMm, latSegments, lonSegments) {
      if (!(radiusMm > 0)) {
        throw new Error("Diameter must be greater than 0.");
      }
      if (latSegments < 2) {
        throw new Error("latSegments must be >= 2.");
      }
      if (lonSegments < 3) {
        throw new Error("lonSegments must be >= 3.");
      }

      const top = [0, 0, radiusMm];
      const bottom = [0, 0, -radiusMm];
      const rings = [];
      for (let i = 1; i < latSegments; i += 1) {
        const theta = Math.PI * i / latSegments;
        const z = radiusMm * Math.cos(theta);
        const ringRadius = radiusMm * Math.sin(theta);
        const ring = [];
        for (let j = 0; j < lonSegments; j += 1) {
          const phi = 2 * Math.PI * j / lonSegments;
          ring.push([
            ringRadius * Math.cos(phi),
            ringRadius * Math.sin(phi),
            z
          ]);
        }
        rings.push(ring);
      }

      const triangles = [];
      const firstRing = rings[0];
      const lastRing = rings[rings.length - 1];

      for (let j = 0; j < lonSegments; j += 1) {
        triangles.push(orientOutward(top, firstRing[(j + 1) % lonSegments], firstRing[j]));
      }

      for (let ringIdx = 0; ringIdx < rings.length - 1; ringIdx += 1) {
        const ringA = rings[ringIdx];
        const ringB = rings[ringIdx + 1];
        for (let j = 0; j < lonSegments; j += 1) {
          const v00 = ringA[j];
          const v01 = ringA[(j + 1) % lonSegments];
          const v10 = ringB[j];
          const v11 = ringB[(j + 1) % lonSegments];
          triangles.push(orientOutward(v00, v01, v11));
          triangles.push(orientOutward(v00, v11, v10));
        }
      }

      for (let j = 0; j < lonSegments; j += 1) {
        triangles.push(orientOutward(bottom, lastRing[j], lastRing[(j + 1) % lonSegments]));
      }

      return triangles;
    }

    function buildHemisphereMesh(radiusMm, latSegments, lonSegments, splitHalf, includeEquatorCap = true) {
      if (!(radiusMm > 0)) {
        throw new Error("Diameter must be greater than 0.");
      }
      if (splitHalf !== "up" && splitHalf !== "down") {
        throw new Error("splitHalf must be 'up' or 'down'.");
      }

      const hemiLatSegments = Math.max(1, Math.floor(latSegments / 2));
      const pole = [0, 0, splitHalf === "up" ? radiusMm : -radiusMm];
      const rings = [];

      for (let i = 1; i <= hemiLatSegments; i += 1) {
        const theta = (Math.PI / 2) * i / hemiLatSegments;
        const ringRadius = radiusMm * Math.sin(theta);
        const z = snapNearZero((splitHalf === "up" ? 1 : -1) * radiusMm * Math.cos(theta));
        const ring = [];
        for (let j = 0; j < lonSegments; j += 1) {
          const phi = 2 * Math.PI * j / lonSegments;
          ring.push([
            ringRadius * Math.cos(phi),
            ringRadius * Math.sin(phi),
            z
          ]);
        }
        rings.push(ring);
      }

      const triangles = [];
      const firstRing = rings[0];

      for (let j = 0; j < lonSegments; j += 1) {
        if (splitHalf === "up") {
          triangles.push(orientOutward(pole, firstRing[(j + 1) % lonSegments], firstRing[j]));
        } else {
          triangles.push(orientOutward(pole, firstRing[j], firstRing[(j + 1) % lonSegments]));
        }
      }

      for (let ringIdx = 0; ringIdx < rings.length - 1; ringIdx += 1) {
        const ringA = rings[ringIdx];
        const ringB = rings[ringIdx + 1];
        for (let j = 0; j < lonSegments; j += 1) {
          const v00 = ringA[j];
          const v01 = ringA[(j + 1) % lonSegments];
          const v10 = ringB[j];
          const v11 = ringB[(j + 1) % lonSegments];
          triangles.push(orientOutward(v00, v01, v11));
          triangles.push(orientOutward(v00, v11, v10));
        }
      }

      if (includeEquatorCap) {
        const center = [0, 0, 0];
        const equator = rings[rings.length - 1];
        for (let j = 0; j < lonSegments; j += 1) {
          if (splitHalf === "up") {
            triangles.push({
              v1: center,
              v2: equator[(j + 1) % lonSegments],
              v3: equator[j]
            });
          } else {
            triangles.push({
              v1: center,
              v2: equator[j],
              v3: equator[(j + 1) % lonSegments]
            });
          }
        }
      }

      return triangles;
    }

    function buildCubeVoidMesh(edgeMm) {
      if (!(edgeMm > 0)) {
        throw new Error("Cube void size must be greater than 0.");
      }
      const half = edgeMm / 2;
      const faces = [
        [[half, -half, -half], [half, half, -half], [half, half, half], [half, -half, half]],
        [[-half, -half, -half], [-half, -half, half], [-half, half, half], [-half, half, -half]],
        [[-half, half, -half], [-half, half, half], [half, half, half], [half, half, -half]],
        [[-half, -half, -half], [half, -half, -half], [half, -half, half], [-half, -half, half]],
        [[-half, -half, half], [half, -half, half], [half, half, half], [-half, half, half]],
        [[-half, -half, -half], [-half, half, -half], [half, half, -half], [half, -half, -half]]
      ];

      const triangles = [];
      for (const [a, b, c, d] of faces) {
        triangles.push(orientInward(a, b, c));
        triangles.push(orientInward(a, c, d));
      }
      return triangles;
    }

    function flipTriangleWinding(tri) {
      return { v1: tri.v1, v2: tri.v3, v3: tri.v2 };
    }

    function validateVoidConfig(diameter, voidShape, voidSize) {
      if (voidShape === "none") {
        return;
      }
      if (!Number.isFinite(voidSize) || voidSize <= 0) {
        throw new Error("Please enter a void size greater than 0.");
      }

      const outerRadius = diameter / 2;
      if (voidShape === "sphere") {
        const voidRadius = voidSize / 2;
        if (voidRadius >= outerRadius) {
          throw new Error("Sphere void diameter must be smaller than the outer sphere diameter.");
        }
        return;
      }

      if (voidShape === "cube") {
        const halfDiagonal = (voidSize * Math.sqrt(2)) / 2;
        if (halfDiagonal >= outerRadius) {
          throw new Error("Cube void is too large; its z=0 cross-section diagonal must fit inside the sphere.");
        }
        return;
      }

      throw new Error(`Unsupported void shape: ${voidShape}`);
    }

    function validateSplitConfig(splitHalf, voidShape) {
      if (!["none", "up", "down", "both"].includes(splitHalf)) {
        throw new Error("Unsupported split option.");
      }
    }

    function orientTriangleToZ(v1, v2, v3, positiveZ) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const needsFlip = positiveZ ? (n[2] < 0) : (n[2] > 0);
      return needsFlip ? { v1, v2: v3, v3: v2 } : { v1, v2, v3 };
    }

    function buildEquatorRing(radiusMm, lonSegments) {
      const ring = [];
      for (let j = 0; j < lonSegments; j += 1) {
        const phi = 2 * Math.PI * j / lonSegments;
        ring.push([radiusMm * Math.cos(phi), radiusMm * Math.sin(phi), 0]);
      }
      return ring;
    }

    function buildSquareBoundaryRing(halfEdgeMm, lonSegments) {
      const ring = [];
      for (let j = 0; j < lonSegments; j += 1) {
        const phi = 2 * Math.PI * j / lonSegments;
        const c = Math.cos(phi);
        const s = Math.sin(phi);
        const scale = halfEdgeMm / Math.max(Math.abs(c), Math.abs(s));
        ring.push([scale * c, scale * s, 0]);
      }
      return ring;
    }

    function buildSplitCapBetweenRings(outerRing, innerRing, splitHalf) {
      if (outerRing.length !== innerRing.length) {
        throw new Error("Split cap rings must have the same segment count.");
      }
      if (splitHalf !== "up" && splitHalf !== "down") {
        throw new Error("Split cap requires splitHalf=up or down.");
      }

      const triangles = [];
      const positiveZ = splitHalf === "down";
      for (let j = 0; j < outerRing.length; j += 1) {
        const o0 = outerRing[j];
        const o1 = outerRing[(j + 1) % outerRing.length];
        const i0 = innerRing[j];
        const i1 = innerRing[(j + 1) % innerRing.length];
        triangles.push(orientTriangleToZ(o0, o1, i1, positiveZ));
        triangles.push(orientTriangleToZ(o0, i1, i0, positiveZ));
      }
      return triangles;
    }

    function buildCubeCavityHalfOpenMesh(edgeMm, lonSegments, splitHalf) {
      if (!(edgeMm > 0)) {
        throw new Error("Cube void size must be greater than 0.");
      }
      if (splitHalf !== "up" && splitHalf !== "down") {
        throw new Error("Cube split cavity requires splitHalf=up or down.");
      }

      const half = edgeMm / 2;
      const splitRing = buildSquareBoundaryRing(half, lonSegments);
      const zFar = splitHalf === "up" ? half : -half;
      const farRing = splitRing.map(([x, y]) => [x, y, zFar]);
      const triangles = [];

      for (let j = 0; j < lonSegments; j += 1) {
        const s0 = splitRing[j];
        const s1 = splitRing[(j + 1) % lonSegments];
        const f0 = farRing[j];
        const f1 = farRing[(j + 1) % lonSegments];
        triangles.push(orientInward(s0, s1, f1));
        triangles.push(orientInward(s0, f1, f0));
      }

      const centerFar = [0, 0, zFar];
      for (let j = 0; j < lonSegments; j += 1) {
        const f0 = farRing[j];
        const f1 = farRing[(j + 1) % lonSegments];
        triangles.push(orientInward(centerFar, f0, f1));
      }

      return { triangles, splitRing };
    }

    function buildSplitVoidHalfMesh(diameter, latSegments, lonSegments, voidShape, voidSize, splitHalf) {
      const radius = diameter / 2;
      if (voidShape === "none") {
        return buildHemisphereMesh(radius, latSegments, lonSegments, splitHalf);
      }

      validateVoidConfig(diameter, voidShape, voidSize);
      const outerSurface = buildHemisphereMesh(radius, latSegments, lonSegments, splitHalf, false);
      const outerRing = buildEquatorRing(radius, lonSegments);

      let innerSurface;
      let innerRing;
      if (voidShape === "sphere") {
        const innerRadius = voidSize / 2;
        innerSurface = buildHemisphereMesh(innerRadius, latSegments, lonSegments, splitHalf, false)
          .map(flipTriangleWinding);
        innerRing = buildEquatorRing(innerRadius, lonSegments);
      } else if (voidShape === "cube") {
        const cubeHalf = buildCubeCavityHalfOpenMesh(voidSize, lonSegments, splitHalf);
        innerSurface = cubeHalf.triangles;
        innerRing = cubeHalf.splitRing;
      } else {
        throw new Error(`Unsupported void shape: ${voidShape}`);
      }

      const splitCap = buildSplitCapBetweenRings(outerRing, innerRing, splitHalf);
      return outerSurface.concat(innerSurface, splitCap);
    }

    function buildSingleBodyMesh(diameter, latSegments, lonSegments, voidShape, voidSize, splitHalf) {
      if (!Number.isFinite(diameter) || diameter <= 0) {
        throw new Error("Please enter a valid diameter greater than 0.");
      }

      validateSplitConfig(splitHalf, voidShape);

      if (splitHalf === "up" || splitHalf === "down") {
        return buildSplitVoidHalfMesh(diameter, latSegments, lonSegments, voidShape, voidSize, splitHalf);
      }

      const radius = diameter / 2;
      const outerTriangles = buildSphereMesh(radius, latSegments, lonSegments);
      validateVoidConfig(diameter, voidShape, voidSize);

      if (voidShape === "none") {
        return outerTriangles;
      }
      if (voidShape === "sphere") {
        return outerTriangles.concat(
          buildSphereMesh(voidSize / 2, latSegments, lonSegments).map(flipTriangleWinding)
        );
      }
      if (voidShape === "cube") {
        return outerTriangles.concat(buildCubeVoidMesh(voidSize));
      }
      throw new Error(`Unsupported void shape: ${voidShape}`);
    }

    function buildObjectBodyMeshes(diameter, latSegments, lonSegments, voidShape, voidSize, splitHalf) {
      validateSplitConfig(splitHalf, voidShape);
      if (splitHalf === "both") {
        return [
          buildSingleBodyMesh(diameter, latSegments, lonSegments, voidShape, voidSize, "up"),
          buildSingleBodyMesh(diameter, latSegments, lonSegments, voidShape, voidSize, "down")
        ];
      }
      return [buildSingleBodyMesh(diameter, latSegments, lonSegments, voidShape, voidSize, splitHalf)];
    }

    function buildTiledSphereMeshes(
      diameter,
      latSegments,
      lonSegments,
      voidShape,
      voidSize,
      splitHalf,
      arrayX,
      arrayY,
      arraySpacing
    ) {
      validateArrayConfig(arrayX, arrayY, arraySpacing);
      if (splitHalf === "both") {
        // Keep 3MF body order deterministic: all uppers first, then all lowers.
        const upperMesh = buildSingleBodyMesh(
          diameter,
          latSegments,
          lonSegments,
          voidShape,
          voidSize,
          "up"
        );
        const lowerMesh = buildSingleBodyMesh(
          diameter,
          latSegments,
          lonSegments,
          voidShape,
          voidSize,
          "down"
        );
        const upperBodies = tileBodyMeshes2D([upperMesh], arrayX, arrayY, arraySpacing);
        const lowerBodies = tileBodyMeshes2D([lowerMesh], arrayX, arrayY, arraySpacing);
        return upperBodies.concat(lowerBodies);
      }
      const baseBodyMeshes = buildObjectBodyMeshes(
        diameter,
        latSegments,
        lonSegments,
        voidShape,
        voidSize,
        splitHalf
      );
      return tileBodyMeshes2D(baseBodyMeshes, arrayX, arrayY, arraySpacing);
    }

    function offsetPoint(v, dx, dy, dz) {
      return [v[0] + dx, v[1] + dy, v[2] + dz];
    }

    function offsetTriangle(tri, dx, dy, dz) {
      return {
        v1: offsetPoint(tri.v1, dx, dy, dz),
        v2: offsetPoint(tri.v2, dx, dy, dz),
        v3: offsetPoint(tri.v3, dx, dy, dz)
      };
    }

    function validateArrayConfig(arrayX, arrayY, arraySpacing) {
      if (!Number.isInteger(arrayX) || arrayX < 1) {
        throw new Error("Array Count X must be an integer >= 1.");
      }
      if (!Number.isInteger(arrayY) || arrayY < 1) {
        throw new Error("Array Count Y must be an integer >= 1.");
      }
      if ((arrayX > 1 || arrayY > 1) && (!Number.isFinite(arraySpacing) || arraySpacing <= 0)) {
        throw new Error("Array spacing must be greater than 0 when generating multiple objects.");
      }
    }

    function tileMesh2D(baseTriangles, arrayX, arrayY, arraySpacing) {
      validateArrayConfig(arrayX, arrayY, arraySpacing);
      if (arrayX === 1 && arrayY === 1) {
        return baseTriangles.slice();
      }

      const triangles = [];
      const xCenter = (arrayX - 1) / 2;
      const yCenter = (arrayY - 1) / 2;
      for (let yi = 0; yi < arrayY; yi += 1) {
        const dy = (yi - yCenter) * arraySpacing;
        for (let xi = 0; xi < arrayX; xi += 1) {
          const dx = (xi - xCenter) * arraySpacing;
          for (const tri of baseTriangles) {
            triangles.push(offsetTriangle(tri, dx, dy, 0));
          }
        }
      }
      return triangles;
    }

    function tileBodyMeshes2D(baseMeshes, arrayX, arrayY, arraySpacing) {
      validateArrayConfig(arrayX, arrayY, arraySpacing);
      const list = [];
      const xCenter = (arrayX - 1) / 2;
      const yCenter = (arrayY - 1) / 2;
      for (let yi = 0; yi < arrayY; yi += 1) {
        const dy = (yi - yCenter) * arraySpacing;
        for (let xi = 0; xi < arrayX; xi += 1) {
          const dx = (xi - xCenter) * arraySpacing;
          for (const mesh of baseMeshes) {
            list.push(mesh.map((tri) => offsetTriangle(tri, dx, dy, 0)));
          }
        }
      }
      return list;
    }

    function flattenMeshList(meshList) {
      const out = [];
      for (const mesh of meshList) {
        out.push(...mesh);
      }
      return out;
    }

    function orientTriangleAwayFromPoint(v1, v2, v3, insidePoint) {
      const n = cross(subtract(v2, v1), subtract(v3, v1));
      const c = average(v1, v2, v3);
      const toFace = subtract(c, insidePoint);
      if (dot(n, toFace) < 0) {
        return { v1, v2: v3, v3: v2 };
      }
      return { v1, v2, v3 };
    }

    function buildAnchorPyramidMesh(centerX, centerY, baseZ, diameter) {
      const halfFootprint = 2.5;
      const height = diameter / 2;
      if (!Number.isFinite(height) || height <= 0) {
        throw new Error("Sphere diameter must be greater than 0 for anchors.");
      }

      const p00 = [centerX - halfFootprint, centerY - halfFootprint, baseZ];
      const p10 = [centerX + halfFootprint, centerY - halfFootprint, baseZ];
      const p11 = [centerX + halfFootprint, centerY + halfFootprint, baseZ];
      const p01 = [centerX - halfFootprint, centerY + halfFootprint, baseZ];
      const apex = [centerX, centerY, baseZ + height];
      const insidePoint = [centerX, centerY, baseZ + (height / 4)];

      return [
        orientTriangleAwayFromPoint(p00, p10, apex, insidePoint),
        orientTriangleAwayFromPoint(p10, p11, apex, insidePoint),
        orientTriangleAwayFromPoint(p11, p01, apex, insidePoint),
        orientTriangleAwayFromPoint(p01, p00, apex, insidePoint),
        orientTriangleAwayFromPoint(p00, p11, p10, insidePoint),
        orientTriangleAwayFromPoint(p00, p01, p11, insidePoint)
      ];
    }

    function cornerAnchorPositions(arrayX, arrayY, arraySpacing) {
      validateArrayConfig(arrayX, arrayY, arraySpacing);
      if (!(arraySpacing > 0)) {
        throw new Error("Array spacing must be greater than 0 when corner anchors are enabled.");
      }

      const xMin = -((arrayX - 1) / 2) * arraySpacing;
      const xMax = ((arrayX - 1) / 2) * arraySpacing;
      const yMin = -((arrayY - 1) / 2) * arraySpacing;
      const yMax = ((arrayY - 1) / 2) * arraySpacing;

      return [
        [xMin - arraySpacing, yMin - arraySpacing],
        [xMax + arraySpacing, yMax + arraySpacing],
        [xMin - arraySpacing, yMax + arraySpacing],
        [xMax + arraySpacing, yMin - arraySpacing]
      ];
    }

    function buildCornerAnchorMeshes(enabled, diameter, arrayX, arrayY, arraySpacing) {
      if (!enabled) {
        return [];
      }
      const baseZ = -diameter / 2;
      return cornerAnchorPositions(arrayX, arrayY, arraySpacing)
        .map(([x, y]) => buildAnchorPyramidMesh(x, y, baseZ, diameter));
    }

    function triangleNormal(tri) {
      return normalize(cross(subtract(tri.v2, tri.v1), subtract(tri.v3, tri.v1)));
    }

    function formatNumber(n) {
      return Number.isFinite(n) ? n.toFixed(8) : "0.00000000";
    }

    function formatDimension(value) {
      return value.toFixed(3).replace(/\.?0+$/, "").replace(".", "p");
    }

    function makeFileName(
      diameter,
      voidShape,
      voidSize,
      arrayX,
      arrayY,
      arraySpacing,
      splitHalf,
      cornerAnchors,
      exportFormat
    ) {
      const dText = formatDimension(diameter);
      const arraySuffix = (arrayX === 1 && arrayY === 1)
        ? ""
        : `_arr_${arrayX}x${arrayY}_s${formatDimension(arraySpacing)}mm`;
      const splitSuffix = splitHalf === "none"
        ? ""
        : (splitHalf === "both" ? "_split_both" : `_half_${splitHalf}`);
      const anchorSuffix = cornerAnchors ? "_anchors" : "";

      if (voidShape === "none") {
        return `sphere_${dText}mm${splitSuffix}_solid${arraySuffix}${anchorSuffix}.${exportFormat}`;
      }
      const sText = formatDimension(voidSize);
      return `sphere_${dText}mm${splitSuffix}_void_${voidShape}_${sText}mm${arraySuffix}${anchorSuffix}.${exportFormat}`;
    }

    function build3mfBodyNames(modelName, splitHalf, sphereBodyCount, anchorBodyCount) {
      const names = [];
      if (splitHalf === "both") {
        if (sphereBodyCount % 2 !== 0) {
          throw new Error("split=both expects an even number of sphere bodies.");
        }
        const perHalf = Math.floor(sphereBodyCount / 2);
        for (let i = 1; i <= perHalf; i += 1) {
          names.push(`${modelName}_${i}_A`);
        }
        for (let i = 1; i <= perHalf; i += 1) {
          names.push(`${modelName}_${i}_B`);
        }
      } else if (splitHalf === "up") {
        if (sphereBodyCount === 1) {
          names.push(`${modelName}_A`);
        } else {
          for (let i = 1; i <= sphereBodyCount; i += 1) {
            names.push(`${modelName}_${i}_A`);
          }
        }
      } else if (splitHalf === "down") {
        if (sphereBodyCount === 1) {
          names.push(`${modelName}_B`);
        } else {
          for (let i = 1; i <= sphereBodyCount; i += 1) {
            names.push(`${modelName}_${i}_B`);
          }
        }
      } else if (sphereBodyCount === 1) {
        names.push(modelName);
      } else {
        for (let i = 1; i <= sphereBodyCount; i += 1) {
          names.push(`${modelName}_${i}`);
        }
      }

      for (let i = 1; i <= anchorBodyCount; i += 1) {
        names.push(`anchor_${i}`);
      }
      return names;
    }

    function buildAsciiStl(solidName, triangles) {
      const lines = [];
      lines.push(`solid ${solidName}`);
      for (const tri of triangles) {
        const n = triangleNormal(tri);
        lines.push(`  facet normal ${formatNumber(n[0])} ${formatNumber(n[1])} ${formatNumber(n[2])}`);
        lines.push("    outer loop");
        lines.push(`      vertex ${formatNumber(tri.v1[0])} ${formatNumber(tri.v1[1])} ${formatNumber(tri.v1[2])}`);
        lines.push(`      vertex ${formatNumber(tri.v2[0])} ${formatNumber(tri.v2[1])} ${formatNumber(tri.v2[2])}`);
        lines.push(`      vertex ${formatNumber(tri.v3[0])} ${formatNumber(tri.v3[1])} ${formatNumber(tri.v3[2])}`);
        lines.push("    endloop");
        lines.push("  endfacet");
      }
      lines.push(`endsolid ${solidName}`);
      return `${lines.join("\n")}\n`;
    }

    function xmlEscape(text) {
      return text
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;");
    }

    function buildIndexedMesh(triangles) {
      const vertices = [];
      const triangleIndices = [];
      const indexByVertex = new Map();

      for (const tri of triangles) {
        const triIdx = [];
        for (const vertex of [tri.v1, tri.v2, tri.v3]) {
          const key = `${vertex[0].toFixed(8)},${vertex[1].toFixed(8)},${vertex[2].toFixed(8)}`;
          let idx = indexByVertex.get(key);
          if (idx === undefined) {
            idx = vertices.length;
            vertices.push(vertex);
            indexByVertex.set(key, idx);
          }
          triIdx.push(idx);
        }
        triangleIndices.push(triIdx);
      }

      return { vertices, triangleIndices };
    }

    function build3mfModelXml(modelName, meshList, bodyNames = null) {
      if (bodyNames !== null && bodyNames.length !== meshList.length) {
        throw new Error("3MF body names length must match mesh count.");
      }
      const lines = [];
      lines.push('<?xml version="1.0" encoding="UTF-8"?>');
      lines.push('<model unit="millimeter" xml:lang="en-US" xmlns="http://schemas.microsoft.com/3dmanufacturing/core/2015/02">');
      lines.push("  <resources>");
      for (let objId = 0; objId < meshList.length; objId += 1) {
        const triangles = meshList[objId];
        const indexed = buildIndexedMesh(triangles);
        const bodyName = bodyNames !== null
          ? bodyNames[objId]
          : (meshList.length === 1 ? modelName : `${modelName}_${objId + 1}`);
        lines.push(`    <object id="${objId + 1}" type="model" name="${xmlEscape(bodyName)}">`);
        lines.push("      <mesh>");
        lines.push("        <vertices>");
        for (const vertex of indexed.vertices) {
          lines.push(
            `          <vertex x="${formatNumber(vertex[0])}" y="${formatNumber(vertex[1])}" z="${formatNumber(vertex[2])}"/>`
          );
        }
        lines.push("        </vertices>");
        lines.push("        <triangles>");
        for (const tri of indexed.triangleIndices) {
          lines.push(`          <triangle v1="${tri[0]}" v2="${tri[1]}" v3="${tri[2]}"/>`);
        }
        lines.push("        </triangles>");
        lines.push("      </mesh>");
        lines.push("    </object>");
      }
      lines.push("  </resources>");
      lines.push("  <build>");
      for (let objId = 1; objId <= meshList.length; objId += 1) {
        lines.push(`    <item objectid="${objId}"/>`);
      }
      lines.push("  </build>");
      lines.push("</model>");
      lines.push("");
      return lines.join("\n");
    }

    let crc32Table = null;
    function getCrc32Table() {
      if (crc32Table !== null) {
        return crc32Table;
      }
      crc32Table = new Uint32Array(256);
      for (let n = 0; n < 256; n += 1) {
        let c = n;
        for (let k = 0; k < 8; k += 1) {
          c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
        }
        crc32Table[n] = c >>> 0;
      }
      return crc32Table;
    }

    function crc32(bytes) {
      const table = getCrc32Table();
      let c = 0xffffffff;
      for (let i = 0; i < bytes.length; i += 1) {
        c = table[(c ^ bytes[i]) & 0xff] ^ (c >>> 8);
      }
      return (c ^ 0xffffffff) >>> 0;
    }

    function concatUint8Arrays(parts) {
      let totalLength = 0;
      for (const part of parts) {
        totalLength += part.length;
      }
      const out = new Uint8Array(totalLength);
      let offset = 0;
      for (const part of parts) {
        out.set(part, offset);
        offset += part.length;
      }
      return out;
    }

    function createStoredZip(entries) {
      const encoder = new TextEncoder();
      const localParts = [];
      const centralParts = [];
      let offset = 0;

      for (const entry of entries) {
        const nameBytes = encoder.encode(entry.name);
        const dataBytes = entry.data;
        const checksum = crc32(dataBytes);

        const localHeader = new Uint8Array(30 + nameBytes.length);
        const localView = new DataView(localHeader.buffer);
        localView.setUint32(0, 0x04034b50, true);
        localView.setUint16(4, 20, true);
        localView.setUint16(6, 0, true);
        localView.setUint16(8, 0, true);
        localView.setUint16(10, 0, true);
        localView.setUint16(12, 0, true);
        localView.setUint32(14, checksum, true);
        localView.setUint32(18, dataBytes.length, true);
        localView.setUint32(22, dataBytes.length, true);
        localView.setUint16(26, nameBytes.length, true);
        localView.setUint16(28, 0, true);
        localHeader.set(nameBytes, 30);
        localParts.push(localHeader, dataBytes);

        const centralHeader = new Uint8Array(46 + nameBytes.length);
        const centralView = new DataView(centralHeader.buffer);
        centralView.setUint32(0, 0x02014b50, true);
        centralView.setUint16(4, 20, true);
        centralView.setUint16(6, 20, true);
        centralView.setUint16(8, 0, true);
        centralView.setUint16(10, 0, true);
        centralView.setUint16(12, 0, true);
        centralView.setUint16(14, 0, true);
        centralView.setUint32(16, checksum, true);
        centralView.setUint32(20, dataBytes.length, true);
        centralView.setUint32(24, dataBytes.length, true);
        centralView.setUint16(28, nameBytes.length, true);
        centralView.setUint16(30, 0, true);
        centralView.setUint16(32, 0, true);
        centralView.setUint16(34, 0, true);
        centralView.setUint16(36, 0, true);
        centralView.setUint32(38, 0, true);
        centralView.setUint32(42, offset, true);
        centralHeader.set(nameBytes, 46);
        centralParts.push(centralHeader);

        offset += localHeader.length + dataBytes.length;
      }

      const centralOffset = offset;
      let centralSize = 0;
      for (const part of centralParts) {
        centralSize += part.length;
      }

      const endOfCentral = new Uint8Array(22);
      const endView = new DataView(endOfCentral.buffer);
      endView.setUint32(0, 0x06054b50, true);
      endView.setUint16(4, 0, true);
      endView.setUint16(6, 0, true);
      endView.setUint16(8, entries.length, true);
      endView.setUint16(10, entries.length, true);
      endView.setUint32(12, centralSize, true);
      endView.setUint32(16, centralOffset, true);
      endView.setUint16(20, 0, true);

      return concatUint8Arrays([...localParts, ...centralParts, endOfCentral]);
    }

    function build3mfBlob(modelName, meshList, bodyNames = null) {
      const encoder = new TextEncoder();
      const contentTypesXml = `<?xml version="1.0" encoding="UTF-8"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
  <Default Extension="model" ContentType="application/vnd.ms-package.3dmanufacturing-3dmodel+xml"/>
</Types>
`;
      const rootRelsXml = `<?xml version="1.0" encoding="UTF-8"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  <Relationship Target="/3D/3dmodel.model" Id="rel0" Type="http://schemas.microsoft.com/3dmanufacturing/2013/01/3dmodel"/>
</Relationships>
`;
      const modelXml = build3mfModelXml(modelName, meshList, bodyNames);
      const zipBytes = createStoredZip([
        { name: "[Content_Types].xml", data: encoder.encode(contentTypesXml) },
        { name: "_rels/.rels", data: encoder.encode(rootRelsXml) },
        { name: "3D/3dmodel.model", data: encoder.encode(modelXml) }
      ]);
      return new Blob([zipBytes], { type: "model/3mf" });
    }

    function downloadBlob(fileName, blob) {
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      link.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    const statusEl = document.getElementById("status");
    function setStatus(message, isError) {
      statusEl.textContent = message;
      statusEl.className = isError ? "err" : "ok";
    }

    const diameterEl = document.getElementById("diameter");
    const splitHalfEl = document.getElementById("split-half");
    const splitHalfHintEl = document.getElementById("split-half-hint");
    const voidShapeEl = document.getElementById("void-shape");
    const voidSizeEl = document.getElementById("void-size");
    const voidSizeLabelEl = document.getElementById("void-size-label");
    const voidSizeHintEl = document.getElementById("void-size-hint");
    const arrayXEl = document.getElementById("array-x");
    const arrayYEl = document.getElementById("array-y");
    const arraySpacingEl = document.getElementById("array-spacing");
    const arraySpacingHintEl = document.getElementById("array-spacing-hint");
    const cornerAnchorsEl = document.getElementById("corner-anchors");
    const exportFormatEl = document.getElementById("export-format");

    function updateVoidUi() {
      const splitHalf = splitHalfEl.value;
      if (splitHalf === "both") {
        splitHalfHintEl.textContent = "Both halves are generated after void subtraction; 3MF exports them as separate bodies.";
      } else if (splitHalf === "up" || splitHalf === "down") {
        splitHalfHintEl.textContent = "Split mode creates one watertight half with a flat face at Z=0.";
      } else {
        splitHalfHintEl.textContent = "None keeps the full sphere.";
      }

      const shape = voidShapeEl.value;
      const hasVoid = shape !== "none";
      voidSizeEl.disabled = !hasVoid;

      if (!hasVoid) {
        voidSizeLabelEl.textContent = "Void Size (mm)";
        voidSizeHintEl.textContent = "Enable by choosing an internal void shape.";
        return;
      }

      if (shape === "sphere") {
        voidSizeLabelEl.textContent = "Void Sphere Diameter (mm)";
        voidSizeHintEl.textContent = "The void sphere diameter must be smaller than the outer sphere diameter.";
        return;
      }

      voidSizeLabelEl.textContent = "Void Cube Edge Length (mm)";
      voidSizeHintEl.textContent = "The cube diagonal at z=0 must fit inside the sphere (larger corner-overlap is allowed).";
    }

    function updateArraySpacingUi() {
      const arrayX = Number(arrayXEl.value);
      const arrayY = Number(arrayYEl.value);
      const anchorsEnabled = cornerAnchorsEl.value === "on";
      const needsSpacing =
        anchorsEnabled ||
        (Number.isInteger(arrayX) && arrayX > 1) ||
        (Number.isInteger(arrayY) && arrayY > 1);
      arraySpacingEl.disabled = !needsSpacing;
      if (anchorsEnabled) {
        arraySpacingHintEl.textContent =
          "Center-to-center spacing is also used to place corner anchors one spacing outside the array.";
      } else {
        arraySpacingHintEl.textContent = needsSpacing
          ? "Center-to-center distance used along X and Y."
          : "Single object (1x1): spacing is ignored.";
      }
    }

    const previewCanvas = document.getElementById("preview-canvas");
    const previewNoteEl = document.getElementById("preview-note");
    const zoomOutEl = document.getElementById("zoom-out");
    const zoomInEl = document.getElementById("zoom-in");
    const zoomResetEl = document.getElementById("zoom-reset");
    const zoomLevelEl = document.getElementById("zoom-level");
    const previewCtx = previewCanvas.getContext("2d");
    let previewTriangles = [];
    let previewModelRadius = 1;
    let previewAngle = 0;
    let previewZoom = 1;

    function clamp01(v) {
      if (v < 0) {
        return 0;
      }
      if (v > 1) {
        return 1;
      }
      return v;
    }

    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }

    function updateZoomLevelText() {
      zoomLevelEl.textContent = `${Math.round(previewZoom * 100)}%`;
    }

    function setPreviewZoom(nextZoom) {
      previewZoom = clamp(nextZoom, PREVIEW_MIN_ZOOM, PREVIEW_MAX_ZOOM);
      updateZoomLevelText();
    }

    function estimateMeshRadius(triangles) {
      let maxRadius = 1;
      for (const tri of triangles) {
        for (const vertex of [tri.v1, tri.v2, tri.v3]) {
          const radius = Math.sqrt(
            vertex[0] * vertex[0] +
            vertex[1] * vertex[1] +
            vertex[2] * vertex[2]
          );
          if (radius > maxRadius) {
            maxRadius = radius;
          }
        }
      }
      return maxRadius;
    }

    function rotatePoint(point, yaw, pitch) {
      const x1 = point[0] * Math.cos(yaw) - point[1] * Math.sin(yaw);
      const y1 = point[0] * Math.sin(yaw) + point[1] * Math.cos(yaw);
      const z1 = point[2];

      const y2 = y1 * Math.cos(pitch) - z1 * Math.sin(pitch);
      const z2 = y1 * Math.sin(pitch) + z1 * Math.cos(pitch);
      return [x1, y2, z2];
    }

    function projectPoint(point, cameraDistance, scale, cx, cy) {
      const denom = cameraDistance - point[1];
      const safeDenom = denom <= 0.001 ? 0.001 : denom;
      return [
        cx + (point[0] / safeDenom) * scale,
        cy - (point[2] / safeDenom) * scale
      ];
    }

    function drawPreviewFrame() {
      if (!previewCtx) {
        return;
      }

      const width = previewCanvas.width;
      const height = previewCanvas.height;
      previewCtx.clearRect(0, 0, width, height);
      previewCtx.fillStyle = "#eef3ff";
      previewCtx.fillRect(0, 0, width, height);

      if (!previewTriangles.length) {
        previewCtx.fillStyle = "#6b7b98";
        previewCtx.font = "16px Arial";
        previewCtx.textAlign = "center";
        previewCtx.fillText("Preview unavailable for current inputs.", width / 2, height / 2);
        return;
      }

      previewAngle += 0.012;
      const yaw = previewAngle;
      const pitch = -0.62;
      const transformed = [];

      for (const tri of previewTriangles) {
        const a = rotatePoint(tri.v1, yaw, pitch);
        const b = rotatePoint(tri.v2, yaw, pitch);
        const c = rotatePoint(tri.v3, yaw, pitch);
        transformed.push({ a, b, c });
      }

      const baseRadius = Math.max(previewModelRadius, 1e-6);
      const baseCameraDistance = baseRadius * PREVIEW_BASE_CAMERA_DISTANCE_FACTOR;
      const minCameraDistance = baseRadius * 1.25;
      const cameraDistance = Math.max(minCameraDistance, baseCameraDistance / previewZoom);
      const scale = Math.min(width, height) * 0.92;
      const centerX = width / 2;
      const centerY = height / 2;
      const lightDir = normalize([0.4, -0.85, 0.55]);
      const faces = [];

      for (const tri of transformed) {
        const normal = normalize(cross(subtract(tri.b, tri.a), subtract(tri.c, tri.a)));
        const brightness = clamp01(0.32 + 0.68 * Math.max(0, dot(normal, lightDir)));
        const depth = (tri.a[1] + tri.b[1] + tri.c[1]) / 3;
        faces.push({
          depth,
          brightness,
          p1: projectPoint(tri.a, cameraDistance, scale, centerX, centerY),
          p2: projectPoint(tri.b, cameraDistance, scale, centerX, centerY),
          p3: projectPoint(tri.c, cameraDistance, scale, centerX, centerY)
        });
      }

      faces.sort((f1, f2) => f1.depth - f2.depth);

      for (const face of faces) {
        const shade = Math.round(75 + face.brightness * 145);
        const blue = Math.round(150 + face.brightness * 95);
        previewCtx.beginPath();
        previewCtx.moveTo(face.p1[0], face.p1[1]);
        previewCtx.lineTo(face.p2[0], face.p2[1]);
        previewCtx.lineTo(face.p3[0], face.p3[1]);
        previewCtx.closePath();
        previewCtx.fillStyle = `rgb(${shade}, ${shade}, ${blue})`;
        previewCtx.fill();
        previewCtx.strokeStyle = "rgba(35, 54, 96, 0.12)";
        previewCtx.lineWidth = 0.5;
        previewCtx.stroke();
      }
    }

    function refreshPreviewMesh() {
      const diameter = Number(diameterEl.value);
      const splitHalf = splitHalfEl.value;
      const voidShape = voidShapeEl.value;
      const voidSize = Number(voidSizeEl.value);
      const arrayX = Number(arrayXEl.value);
      const arrayY = Number(arrayYEl.value);
      const arraySpacing = Number(arraySpacingEl.value);
      const cornerAnchors = cornerAnchorsEl.value === "on";

      const notes = [];
      try {
        const previewSplitHalf = splitHalf === "both" ? "none" : splitHalf;
        if (splitHalf === "both") {
          notes.push("Preview does not show split-both; download output still uses separate up/down halves.");
        }

        let previewBodies = buildTiledSphereMeshes(
          diameter,
          PREVIEW_LAT_SEGMENTS,
          PREVIEW_LON_SEGMENTS,
          voidShape,
          voidSize,
          previewSplitHalf,
          1,
          1,
          1
        );

        if (Number.isInteger(arrayX) && Number.isInteger(arrayY)) {
          const objectCount = arrayX * arrayY;
          if (objectCount <= PREVIEW_MAX_OBJECTS) {
            previewBodies = buildTiledSphereMeshes(
              diameter,
              PREVIEW_LAT_SEGMENTS,
              PREVIEW_LON_SEGMENTS,
              voidShape,
              voidSize,
              previewSplitHalf,
              arrayX,
              arrayY,
              arraySpacing
            );
          } else {
            notes.push(`Array has ${objectCount} objects, preview shows one position for speed.`);
          }
        }

        if (cornerAnchors) {
          previewBodies = previewBodies.concat(
            buildCornerAnchorMeshes(true, diameter, arrayX, arrayY, arraySpacing)
          );
        }

        let mesh = flattenMeshList(previewBodies);
        previewModelRadius = estimateMeshRadius(mesh);
        if (mesh.length > PREVIEW_TRIANGLE_LIMIT) {
          const step = Math.ceil(mesh.length / PREVIEW_TRIANGLE_LIMIT);
          mesh = mesh.filter((_, idx) => idx % step === 0);
          notes.push(`Preview decimated to ${mesh.length} triangles for responsiveness.`);
        } else {
          notes.push(`Preview triangles: ${mesh.length}.`);
        }

        previewTriangles = mesh;
        previewNoteEl.textContent = notes.join(" ");
        previewNoteEl.className = "hint";
      } catch (error) {
        previewTriangles = [];
        previewModelRadius = 1;
        previewNoteEl.textContent = error instanceof Error ? error.message : "Preview failed.";
        previewNoteEl.className = "hint err";
      }
    }

    function animationLoop() {
      drawPreviewFrame();
      requestAnimationFrame(animationLoop);
    }

    function refreshUiAndPreview() {
      updateVoidUi();
      updateArraySpacingUi();
      refreshPreviewMesh();
    }

    splitHalfEl.addEventListener("change", refreshUiAndPreview);
    voidShapeEl.addEventListener("change", refreshUiAndPreview);
    arrayXEl.addEventListener("input", refreshUiAndPreview);
    arrayYEl.addEventListener("input", refreshUiAndPreview);
    arraySpacingEl.addEventListener("input", refreshUiAndPreview);
    cornerAnchorsEl.addEventListener("change", refreshUiAndPreview);
    diameterEl.addEventListener("input", refreshUiAndPreview);
    voidSizeEl.addEventListener("input", refreshUiAndPreview);

    exportFormatEl.addEventListener("change", refreshPreviewMesh);
    previewCanvas.addEventListener("wheel", (event) => {
      event.preventDefault();
      if (event.deltaY < 0) {
        setPreviewZoom(previewZoom * 1.1);
      } else {
        setPreviewZoom(previewZoom / 1.1);
      }
    }, { passive: false });
    zoomInEl.addEventListener("click", () => setPreviewZoom(previewZoom * 1.2));
    zoomOutEl.addEventListener("click", () => setPreviewZoom(previewZoom / 1.2));
    zoomResetEl.addEventListener("click", () => setPreviewZoom(1.0));

    updateZoomLevelText();
    refreshUiAndPreview();
    animationLoop();

    document.getElementById("generate").addEventListener("click", () => {
      const button = document.getElementById("generate");
      const diameter = Number(diameterEl.value);
      const splitHalf = splitHalfEl.value;
      const voidShape = voidShapeEl.value;
      const voidSize = Number(voidSizeEl.value);
      const arrayX = Number(arrayXEl.value);
      const arrayY = Number(arrayYEl.value);
      const arraySpacing = Number(arraySpacingEl.value);
      const cornerAnchors = cornerAnchorsEl.value === "on";
      const exportFormat = exportFormatEl.value;

      button.disabled = true;
      button.textContent = "Generating...";

      try {
        const sphereMeshList = buildTiledSphereMeshes(
          diameter,
          LAT_SEGMENTS,
          LON_SEGMENTS,
          voidShape,
          voidSize,
          splitHalf,
          arrayX,
          arrayY,
          arraySpacing
        );
        const anchorMeshList = buildCornerAnchorMeshes(
          cornerAnchors,
          diameter,
          arrayX,
          arrayY,
          arraySpacing
        );
        const meshList = sphereMeshList.concat(anchorMeshList);
        const triangles = flattenMeshList(meshList);
        const sphereInstances = arrayX * arrayY;
        const bodyCount = meshList.length;

        let solidName = "sphere_solid";
        if (splitHalf === "up") {
          solidName = "sphere_upper_half";
        } else if (splitHalf === "down") {
          solidName = "sphere_lower_half";
        } else if (splitHalf === "both") {
          solidName = "sphere_split_halves";
        } else if (voidShape !== "none") {
          solidName = `sphere_with_${voidShape}_void`;
        }

        const fileName = makeFileName(
          diameter,
          voidShape,
          voidSize,
          arrayX,
          arrayY,
          arraySpacing,
          splitHalf,
          cornerAnchors,
          exportFormat
        );

        if (exportFormat === "stl") {
          const stlText = buildAsciiStl(solidName, triangles);
          downloadBlob(fileName, new Blob([stlText], { type: "model/stl" }));
        } else if (exportFormat === "3mf") {
          const bodyNames = build3mfBodyNames(
            solidName,
            splitHalf,
            sphereMeshList.length,
            anchorMeshList.length
          );
          downloadBlob(fileName, build3mfBlob(solidName, meshList, bodyNames));
        } else {
          throw new Error(`Unsupported export format: ${exportFormat}`);
        }

        const voidText = voidShape === "none" ? "no internal void" : `void=${voidShape} (${voidSize} mm)`;
        const splitText = splitHalf === "none" ? "full sphere" : `split=${splitHalf}`;
        const arrayText = `array=${arrayX}x${arrayY}${(arrayX > 1 || arrayY > 1) ? ` @ ${arraySpacing} mm` : ""}`;
        const anchorText = `anchors=${cornerAnchors ? "on" : "off"}`;
        setStatus(
          `Done. Downloaded ${fileName} (${exportFormat.toUpperCase()}), facets=${triangles.length}, ${splitText}, ${voidText}, ${arrayText}, ${anchorText}, sphere_instances=${sphereInstances}, bodies=${bodyCount}.`,
          false
        );
      } catch (error) {
        setStatus(error instanceof Error ? error.message : "Failed to generate mesh.", true);
      } finally {
        button.disabled = false;
        button.textContent = "Generate and Download";
      }
    });
  </script>
</body>

</html>